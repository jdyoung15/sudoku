<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hello World</title>
    <link rel="stylesheet" href="sudoku.css">
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  </head>
  <body>

		<div id="errors" style="
		  background: #c00;
		  color: #fff;
		  display: none;
		  margin: -20px -20px 20px;
		  padding: 20px;
		  white-space: pre-wrap;
		"></div>

		<div id="root"></div>

    <script type="text/babel">

			window.addEventListener('mousedown', function(e) {
			  document.body.classList.add('mouse-navigation');
			  document.body.classList.remove('kbd-navigation');
			});
			window.addEventListener('keydown', function(e) {
			  if (e.keyCode === 9) {
			    document.body.classList.add('kbd-navigation');
			    document.body.classList.remove('mouse-navigation');
			  }
			});
			window.addEventListener('click', function(e) {
			  if (e.target.tagName === 'A' && e.target.getAttribute('href') === '#') {
			    e.preventDefault();
			  }
			});
			window.onerror = function(message, source, line, col, error) {
			  var text = error ? error.stack || error : message + ' (at ' + source + ':' + line + ':' + col + ')';
			  errors.textContent += text + '\n';
			  errors.style.display = '';
			};
			console.error = (function(old) {
			  return function error() {
			    errors.textContent += Array.prototype.slice.call(arguments).join(' ') + '\n';
			    errors.style.display = '';
			    old.apply(this, arguments);
			  }
			})(console.error);


      /**
       * @returns {Array} Returns this array with its contents in randomized order
       *
       * Source: https://www.kirupa.com/html5/shuffling_array_js.htm
       */
      Array.prototype.shuffle = function() {
          var input = this;
           
          for (var i = input.length-1; i >=0; i--) {
           
              var randomIndex = Math.floor(Math.random()*(i+1)); 
              var itemAtIndex = input[randomIndex]; 
               
              input[randomIndex] = input[i]; 
              input[i] = itemAtIndex;
          }
          return input;
      }

      //// Source: https://stackoverflow.com/questions/3746725/create-a-javascript-array-containing-1-n
      //function createArrayToN(n) {
      //  return Array.apply(null, {length: n}).map(Number.call, Number);
      //}


      var Sudoku = function() {

        // ##################################################
        // Constants
        // ##################################################

        /**
         * The number of rows
         */
        const NUM_ROWS = 9;

        /**
         * The number of columns
         */
        const NUM_COLS = 9;

        /**
         * The total number of squares
         */
        const NUM_SQUARES = NUM_ROWS * NUM_COLS;

        /**
         * The width of a block, in terms of columns
         */
        const BLOCK_WIDTH = 3;

        /**
         * The height of a block, in terms of rows
         */
        const BLOCK_HEIGHT = 3;

        /**
         * The number of blocks in a row of blocks
         */
        const NUM_BLOCKS_PER_ROW = NUM_COLS / BLOCK_WIDTH;

        /**
         * The number of squares in one row of adjacent blocks
         */
        const NUM_SQUARES_PER_ROW_OF_BLOCKS = BLOCK_WIDTH * BLOCK_HEIGHT * NUM_BLOCKS_PER_ROW;

        /**
         * The likelihood that a square will be prefilled with an answer when the game starts
         */
        const DEFAULT_DIFFICULTY_PROBABILITY = 0.5;

        /**
         * The lowest position value for each row 
         */
        const ROW_START_POSITIONS = [0, 9, 18, 27, 36, 45, 54, 63, 72];

        /**
         * The lowest position value for each column
         */
        const COL_START_POSITIONS = [0, 1, 2, 3, 4, 5, 6, 7, 8];

        /**
         * The lowest position value for each block
         */
        const BLOCK_START_POSITIONS = [0, 3, 6, 27, 30, 33, 54, 57, 60]; 

        /**
         * The possible answers for a square
         */
        const POSSIBLE_ANSWERS = [1, 2, 3, 4, 5, 6, 7, 8, 9];


        // ##################################################
        // Functions
        // ##################################################

        /**
         * @param {Number} numSquares - The number of squares to generate
         * @param {Number} probability - The likelilhood that a square will be prefilled with an answer
         * @returns {Array} An array, of numSquares length, containing numbers and nulls. The numbers 
         *   represent answered squares, the nulls empty squares. 
         */
        function generateInitialSquares(numSquares, probability) {
          const squares = Array(numSquares).fill(null);
          const answers = generateAnswers(numSquares);
          answers.forEach((answer, index) => {
            if (Math.random() < probability) {
              squares[index] = answer;
            }
          });
          return squares;
        }

        /**
         * @param {Number} numSquares - The number of answers to generate
         * @returns {Array} An array, of numSquares length, containing numbers representing answered squares
         *
         * Algorithm: https://www.codeproject.com/Articles/23206/Sudoku-Algorithm-Generates-a-Valid-Sudoku-in
         */
        function generateAnswers(numSquares) {
          const answers = Array(numSquares);
          const possibleAnswersBySquare = Array(numSquares).fill(null);
          possibleAnswersBySquare.forEach((possibleAnswer, index, ary) => {
            ary[index] = POSSIBLE_ANSWERS.slice().shuffle();
          });

          let position = 0;
          while (position < numSquares) {
            let possibleAnswers = possibleAnswersBySquare[position]; 

            // If no remaining possible answers for this square, replenish answers and backtrack one square
            if (possibleAnswers.length === 0) {
              possibleAnswersBySquare[position] = POSSIBLE_ANSWERS.slice().shuffle();
              answers[position] = null;
              if (position > 0) position--;
              continue;
            }

            answers[position] = possibleAnswers.pop();
            if (!isValid(position, answers)) {
              answers[position] = null;
              continue;
            }

            position++;
          }
          return answers; 
        }

        /**
         * @param {Number} position - Represents the position of the square containing the answer to be checked
         * @param {Array} squares - An array of numbers representing the squares of the Sudoku board
         * @returns {Boolean} Indicates whether the answer at the given position is valid, given the surrounding squares
         */
        function isValid(position, squares) {
          return findConflictingSquaresForPositions(squares, findSquaresInRow(position)).length === 0
            && findConflictingSquaresForPositions(squares, findSquaresInCol(position)).length === 0
           && findConflictingSquaresForPositions(squares, findSquaresInBlock(position)).length === 0;
        }

        /**
         * @param {Array} squares - An array of numbers representing the squares of the Sudoku board
         * @returns {Array} An array of numbers representing the positions of conflicting squares,
         *   that is, duplicate squares in the same row, column, or block.
         */
        function findConflictingSquares(squares) {
          let conflictingSquares = [];

          ROW_START_POSITIONS.forEach(position => {
            conflictingSquares = conflictingSquares.concat(findConflictingSquaresForPositions(squares, findSquaresInRow(position)));
          });
          COL_START_POSITIONS.forEach(position => {
            conflictingSquares = conflictingSquares.concat(findConflictingSquaresForPositions(squares, findSquaresInCol(position)));
          });
          BLOCK_START_POSITIONS.forEach(position => {
            conflictingSquares = conflictingSquares.concat(findConflictingSquaresForPositions(squares, findSquaresInBlock(position)));
          });

          return Array.from(new Set(conflictingSquares));
        }

        /**
         * @param {Array} squares - An array of numbers representing the squares of the Sudoku board
         * @param {Array} positions - An array of numbers representing a group of squares (e.g. a row, column, or block) 
         *   to be checked for duplicates
         * @returns {Array} An array of numbers representing the positions of conflicting squares
         */
        function findConflictingSquaresForPositions(squares, positions) {
          const conflictingSquares = new Set(); 
          // For each square, compare against the remaining squares and record any duplicates
          positions.forEach((position, index) => {
            let value = squares[position];
            // If value is null, no need to compare against other squares
            if (!value) {
              return;
            }
            let remainingPositions = positions.slice(index + 1);
            remainingPositions.forEach(comparisonPosition => {
              let comparisonValue = squares[comparisonPosition];
              if (!comparisonValue) {
                return;
              }
              
              if (value === comparisonValue) {
                conflictingSquares.add(position);
                conflictingSquares.add(comparisonPosition);
              }
            });
          });

          return Array.from(conflictingSquares);
        }

        /**
         * @param {Number} position - The position of a square
         * @returns {Array} An array of numbers representing all squares in the row of the given square
         */
        function findSquaresInRow(position) {
          const rowPositions = [];
          const start = Math.floor(position / NUM_COLS) * NUM_COLS;
          for (let i = start; i < start + NUM_COLS; i++) {
            rowPositions.push(i);
          }
          return rowPositions;
        }

        /**
         * @param {Number} position - The position of a square
         * @returns {Array} An array of numbers representing all squares in the column of the given square
         */
        function findSquaresInCol(position) {
          const colPositions = [];
          const start = position % NUM_COLS;
          for (let i = start; i < NUM_SQUARES; i += NUM_COLS) {
            colPositions.push(i);
          }
          return colPositions;
        }

        /**
         * @param {Number} position - The position of a square
         * @returns {Array} An array of numbers representing all squares in the 3x3 block of the given square
         */
        function findSquaresInBlock(position) {
          const blockPositions = [];
          const startRow = Math.floor(position / NUM_SQUARES_PER_ROW_OF_BLOCKS) * BLOCK_HEIGHT;
          const startCol = Math.floor((position % NUM_COLS) / BLOCK_WIDTH) * BLOCK_WIDTH;
          const start = startRow * NUM_COLS + startCol;
          for (let i = 0; i < BLOCK_WIDTH; i++) {
            for (let j = 0; j < BLOCK_HEIGHT; j++) {
              blockPositions.push((start + i) + (j * NUM_COLS));
            }
          }
          return blockPositions; 
        }

        /**
         * @param {Array} squares - An array of numbers representing the squares of the Sudoku board
         * @returns {Array} An array of numbers representing the positions of squares that contain an answer
         */
        function findFilledSquares(squares) {
          const filledSquares = [];
          squares.forEach((square, index) => {
            if (square) {
              filledSquares.push(index);
            }
          });
          return filledSquares;
        }

        /**
         * @param {Array} squares - An array of numbers representing the squares of the Sudoku board
         * @returns {Boolean} Indicates whether the game, given its current state, has been won
         */
        function isGameWon(squares) {
          if (squares.includes(null)) {
            return false;
          }

          return findConflictingSquares(squares).length == 0;
        }

        return {
          NUM_ROWS: NUM_ROWS,
          NUM_COLS: NUM_COLS,
          NUM_SQUARES: NUM_SQUARES,
          DEFAULT_DIFFICULTY_PROBABILITY: DEFAULT_DIFFICULTY_PROBABILITY,
          generateInitialSquares: generateInitialSquares,
          findConflictingSquares: findConflictingSquares,
          findFilledSquares: findFilledSquares,
          isGameWon: isGameWon
        }

      }();


      // ##################################################
      // React components
      // ##################################################

			function Square(props) {
        const highlighted = props.highlighted ? " highlighted" : "";
        const inactive = props.inactive ? " inactive" : "";
        const conflicting = props.conflicting ? " conflicting" : "";
			  return (
			    <button className={"square" + highlighted + inactive + conflicting} onClick={props.onClick} onKeyDown={event => props.onKeyDown(event.key)} ref={props.squareRef}>
			      {props.value}
			    </button>
			  );
			}
			
			class Board extends React.Component {
			  renderSquare(i) {
          if (this.props.conflictingSquares.includes(i)) {
          }
			    return (
			      <Square
			        value={this.props.squares[i]}
              highlighted={this.props.selectedSquare === i}
              inactive={this.props.prefilledSquares.includes(i)}
              conflicting={this.props.conflictingSquares.includes(i)}
			        onClick={() => this.props.onClick(i)}
              onKeyDown={key => this.props.onKeyDown(i, key)}
              key={"square-" + i}
              squareRef={(element) => this.props.squareRef(element, i)}
			      />
			    );
			  }
			
			  render() {
          const board = [];
          for (let row = 0; row < Sudoku.NUM_ROWS; row++) {
            let squares = [];
            for (let col = 0; col < Sudoku.NUM_COLS; col++) {
              let squarePosition = row * Sudoku.NUM_COLS + col;
              squares.push(this.renderSquare(squarePosition));
            }
            board.push(
              <div className="board-row" key={"board-row-" + row}>
                {squares}
              </div>
            );
          }
			    return (
            <div>
              {board}
            </div>
          );
			  }
			}
			
			class Game extends React.Component {
			  constructor() {
			    super();
			    const squares = Sudoku.generateInitialSquares(Sudoku.NUM_SQUARES, Sudoku.DEFAULT_DIFFICULTY_PROBABILITY);
			    this.state = {
			      squares: squares,
            selectedSquare: null,
            prefilledSquares: Sudoku.findFilledSquares(squares.slice()),
            conflictingSquares: []
			    };
			  }

			  handleClick(i) {
          if (this.state.prefilledSquares.includes(i) || Sudoku.isGameWon(this.state.squares.slice())) {
            return;
          }

          this.setState({
            selectedSquare: i
          });
			  }

        handleKeyDown(i, key) {
			    const squares = this.state.squares.slice();
          if (Sudoku.isGameWon(squares)) {
            return;
          }

          if (key.startsWith("Arrow")) {
            let newPosition;
            switch (key) {
              case "ArrowDown":
                newPosition = (i + Sudoku.NUM_COLS) % 81;
                break;
              case "ArrowLeft":
                newPosition = i % 9 === 0 ? i + Sudoku.NUM_COLS - 1 : i - 1;
                break;
              case "ArrowRight":
                newPosition = i % 9 === Sudoku.NUM_COLS - 1 ? i - Sudoku.NUM_COLS + 1 : i + 1;
                break;
              case "ArrowUp":
                newPosition = i < Sudoku.NUM_COLS ? i - Sudoku.NUM_COLS + Sudoku.NUM_SQUARES : i - Sudoku.NUM_COLS;
                break;
              default:
                newPosition = i;
            }
            this.refs[newPosition].focus();
            this.setState({
              selectedSquare: newPosition
            });
            return;
          }

          if (this.state.prefilledSquares.includes(i)) {
            return;
          }

          let userAnswer;
          if (key === "Backspace") {
            userAnswer = null;
          } else {
            userAnswer = parseInt(key);
            if (isNaN(userAnswer) || userAnswer === 0) {
              return;
            }
          }

          squares[i] = userAnswer;

          const conflictingSquares = Sudoku.findConflictingSquares(squares);

			    this.setState({
			      squares: squares,
            conflictingSquares: conflictingSquares
			    });
        }

			  render() {
			    const squares = this.state.squares.slice();
          const status = Sudoku.isGameWon(squares) ? "You have won the game!" : "";

          this.refs = Array(Sudoku.NUM_SQUARES);

			    return (
			      <div className="game">
			        <div className="game-board">
			          <Board
			            squares={squares}
                  selectedSquare={this.state.selectedSquare}
                  prefilledSquares={this.state.prefilledSquares}
                  conflictingSquares={this.state.conflictingSquares}
			            onClick={i => this.handleClick(i)}
                  onKeyDown={(i, key) => this.handleKeyDown(i, key)}
                  squareRef={(el, i) => this.refs[i] = el}
			          />
			        </div>
			        <div className="game-info">
			          <div>{status}</div>
			        </div>
			      </div>
			    );
			  }
			}
			
			// ========================================
			
			ReactDOM.render(<Game />, document.getElementById("root"));
			

    </script>
  </body>
</html>
